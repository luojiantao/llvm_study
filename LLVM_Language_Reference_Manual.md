# LLVM languagr Reference Manual
SSA：即静态单赋值，Static Single-Assignment，这是一种中间表示形式。 之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。
https://llvm.org/docs/LangRef.html#abstract
## Abstract
这个文档是LLVM 汇编语言的使用手册。LLVM是一种静态单工作分配基于提供类型安全，低等级操作，灵活，有清晰地表示“所有”高级语
言的能力的表示语言。就是在所有阶段使用LLVM编译策略通过相同的代码表示。
## Introduction
LLVM代码表示被设计使用3中不懂的形式:作为一种在内存中的编译语言IR，作为一种在磁盘中的bitcode表示（适应被及时编译程序快速加载），还有一种人类可读的汇编语言表示。为了有效编译转化和分析,这允许LLVM提供一种强大的中间表示,同时提供一种天然的方式来排查问题和可视化转化。这三种不同的LLVM形式都是相等的。这个文档描述人类可读的表示和记号。
LLVM表示的目标是同时达到轻量和低等级还有表现力，类型化和可扩展。这个目标是一种普遍IR的种类，通过在足够低的高等级思想可能清晰的映射到它（类似于微处理器是如何通用IR，允许不同来源的语言能够被映射到它）的等级。通过提供类型信息，LLVM能被当做优化的目标：例如，经过指针分析，它能够被证实一个C的自动变量在当前函数的外部是不能被放访问的，允许将它提示为一个简单的SSA值而不是内存位置

### Well-Formedness
重要的要注意这个文档描述的良好的格式LLVM汇编语言。这里是一种不同的在什么是语法分析器接受和考虑什么是好的形式，例如:下面的执行是语法上OK，但是不是一个好的写法（形式）。
```
%x = add i32 1, %x
```
==因为%x的定义不支配他所有的用途==。LLVM基础设施提供一种可能被用来证明这是一个LLVM模块是好的形式（写法）的验证pass。在解析输入程序之后，在优化器输出bitcode之前，这个pass是通过语法分析器自动运行。在转换过程或者对分析器的输入中，违规行为通过验证pass传递指示错误被指出。

## Identifiers
LLVM标识符来自于两种基本类型：全局和本地。全局标识符（函数，全局变量）以'@'字符开始。本地标识符（注册名字，类型）以‘%’字符开始。另外，为了不同的目的，这里有三种不同标识符的形式：

1. 命名值是代表作为带前缀的字符串。例如,%foo,@DivisionByZero,%a.really.long.identifier。实际上的规则表达式使用的是‘[%@][-a-zA-Z$,_][-a-zA-Z$._0-9]*。在名称中需要其他字符的标识符可以用括号包围起来。特殊的字符可以用"\xx"转义，其中"\xx"是十六进制字符的ASCII码。以这种方式，在名称值中任何字符可以被使用，甚至是引用自己。"\01"前缀能够被用在全局变量为了防止错误。
2. 没有名字的值表示为一个带前缀无符号的数字值。例如，%12,@2,%44
3. 常量，它在下面常量节中被描述。
LLVM 需要前缀开头的值有两个理由：编译器不需要担心关于名称和保留字段的冲突，还有在将来不需要惩罚就可以扩展保留的单词集合。另外，没有命名的标识符允许编译器在没有避免符号表冲突下快速提出临时变量。
LLVM保留字段和其他语言中的保留字段十分相似。这些关键字如不同的操作码('add','bitcast','ret',etc...),如基本的类型名称('void','i32',etc...),还有其他。这些保留字段不会和变量名称冲突，因为没有变量名称以字符('%' or '@')前缀开头.
这里有一个两整数变量'%x'乘以8的LLVM的代码的例子：
简单的方式：
```
%result = mul i32 %x, 8
```
然后降低强度
```
%result = shl i32 %x, 3
```
还有困难的方法
```
%0 = add i32 %x, %x ; yields i32:%0
%1 = add i32 %0, %0 ； yields i32:%1
%result = add i32 %1, %1
```
