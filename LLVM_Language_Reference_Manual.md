# LLVM languagr Reference Manual
SSA：即静态单赋值，Static Single-Assignment，这是一种中间表示形式。 之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次。
https://llvm.org/docs/LangRef.html#abstract
## Abstract
这个文档是LLVM 汇编语言的使用手册。LLVM是一种静态单工作分配基于提供类型安全，低等级操作，灵活，有清晰地表示“所有”高级语
言的能力的表示语言。就是在所有阶段使用LLVM编译策略通过相同的代码表示。
## Introduction
LLVM代码表示被设计使用3中不懂的形式:作为一种在内存中的编译语言IR，作为一种在磁盘中的bitcode表示（适应被及时编译程序快速加载），还有一种人类可读的汇编语言表示。为了有效编译转化和分析,这允许LLVM提供一种强大的中间表示,同时提供一种天然的方式来排查问题和可视化转化。这三种不同的LLVM形式都是相等的。这个文档描述人类可读的表示和记号。
LLVM表示的目标是同时达到轻量和低等级还有表现力，类型化和可扩展。这个目标是一种普遍IR的种类，通过在足够低的高等级思想可能清晰的映射到它（类似于微处理器是如何通用IR，允许不同来源的语言能够被映射到它）的等级。通过提供类型信息，LLVM能被当做优化的目标：例如，经过指针分析，它能够被证实一个C的自动变量在当前函数的外部是不能被放访问的，允许将它提示为一个简单的SSA值而不是内存位置

### Well-Formedness
重要的要注意这个文档描述的良好的格式LLVM汇编语言。这里是一种不同的在什么是语法分析器接受和考虑什么是好的形式，例如:下面的执行是语法上OK，但是不是一个好的写法（形式）。
```
%x = add i32 1, %x
```
==因为%x的定义不支配他所有的用途==。LLVM基础设施提供一种可能被用来证明这是一个LLVM模块是好的形式（写法）的验证pass。在解析输入程序之后，在优化器输出bitcode之前，这个pass是通过语法分析器自动运行。在转换过程或者对分析器的输入中，违规行为通过验证pass传递指示错误被指出。

## Identifiers
LLVM标识符来自于两种基本类型：全局和本地。全局标识符（函数，全局变量）以'@'字符开始。本地标识符（注册名字，类型）以‘%’字符开始。另外，为了不同的目的，这里有三种不同标识符的形式：

1. 命名值是代表作为带前缀的字符串。例如,%foo,@DivisionByZero,%a.really.long.identifier。实际上的规则表达式使用的是‘[%@][-a-zA-Z$,_][-a-zA-Z$._0-9]*。在名称中需要其他字符的标识符可以用括号包围起来。特殊的字符可以用"\xx"转义，其中"\xx"是十六进制字符的ASCII码。以这种方式，在名称值中任何字符可以被使用，甚至是引用自己。"\01"前缀能够被用在全局变量为了防止错误。
2. 没有名字的值表示为一个带前缀无符号的数字值。例如，%12,@2,%44
3. 常量，它在下面常量节中被描述。
LLVM 需要前缀开头的值有两个理由：编译器不需要担心关于名称和保留字段的冲突，还有在将来不需要惩罚就可以扩展保留的单词集合。另外，没有命名的标识符允许编译器在没有避免符号表冲突下快速提出临时变量。
LLVM保留字段和其他语言中的保留字段十分相似。这些关键字如不同的操作码('add','bitcast','ret',etc...),如基本的类型名称('void','i32',etc...),还有其他。这些保留字段不会和变量名称冲突，因为没有变量名称以字符('%' or '@')前缀开头.
这里有一个两整数变量'%x'乘以8的LLVM的代码的例子：
简单的方式：
```
%result = mul i32 %x, 8
```
然后降低强度
```
%result = shl i32 %x, 3
```
还有困难的方法
```
%0 = add i32 %x, %x ; yields i32:%0
%1 = add i32 %0, %0 ； yields i32:%1
%result = add i32 %1, %1
```
这最后一个%x乘以8的方法说明了LLVM的几个重要单词特征：
1. 注释被符号‘；’分隔，并且直到这一行结束
2. 当一个计算的结果没有被分配给一个有名变量，没有命名的临时变量会被创建
3. 匿名的临时变量是按顺序编号（使用一个每函数递增计数器，从0开始）。需要注意，在这个编号中，基本块和匿名函数的参数被包含在其中。例如，如果这个基本块的入口没有给出一个标签名字并且所有的函数参数是有名字的，然后得到匿名变量的名字就是数字0.
这也展示了在这个文档中我们遵循的惯例。当演示指令时，我们将会遵循一条带注释的指令，这个注释定义生成值的类型和名字。
## High Level Structure
### Module Structure
LLVM项目有多个模块组成，每个模块是输入程序的翻译单元。每个模块由函数，全局变量和符号表条目组成。模块可能和LLVM连接器结合在一起，他合并函数(和全局变量)定义，解决前置声明，和合并符号表条目。这里是一个“hello,world”模块的例子：
```
;声明一个作为全局常量的字符串常量
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"
;外部输出函数的声明
declare i32 @puts(i8* nocapture) nounwind

;main函数的定义
define i32 @main(){ ;i32()*
    ;转化[13 x i8]* 到 i8*...
    %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0

    ; 调用 输出函数 打印字符串到标准输出(stdout)
    call i32 @puts(i8* %cast210)
    ret i32 0
}

; 命名元数据
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```
这个例子由全局变量名“.str”,一个“puts”函数的外部声明，一个"main"函数定义和命名元数据“foo”组成。
通常，一个模块是由全局值(这里函数和全局变量都是全句值)的目录组成。全局值由指向内存地址(在这里，指向一个字符的数组和一个函数)的指针体现，并且具有以下连接类型之一。
#### Linkage Types
所有的全局变量和函数都是以下类型的链接之一

- private

    “private”修饰的全局值仅仅对当前模块的对象是直接可访问的。尤其，使用全局“parivate”值连接代码到模块中可能导致这个变量重命名为了避免冲突。因为这个符号是这个模块私有的，所以有的引用可以被更新。在对象文件中的所有符号表中这这些“private”值不展示   

- internal(内部的)

    和"private"相似，但是在对象文件中这个值作为本地符号被展示。这相当于“C”中的关键字“static”的概念。

- available_externally(外部可用)

    使用available_externally的全局连接不会进入到对应的LLVM模块的对象文件中。从连接器的角度看，一个available_externally全局和一个外部声明相等。他们的存在允许在已知的全局的定义选来进行内联和其他优化，这个定义是已知在模块外的某个地方。使用available_externally的全局连接允许随意被丢弃，允许内联和其他优化。这个链接类型只在定义中被允许，而不是声明。
    
- linkonce(链接一次)

    当产生链接时，全局"linkonce"链接会和其他相同名字的链接合并.这个可用于实现一些内联函数，模板或其他代码的形式，它一定会被生成在每个使用它的编译单元中，但是正文的位置可能重写当后来有一个更确定的定义.未引用的"linkonce"全局链接允许被丢弃.要注意的是"linkonce"实际上不允许优化器内联函数的正文到调用方中，因为不知道这个函数的定义确定声明在这个程序或者会被更强大的定义重写.为了激活内联和其他优化可以使用"linkonce_odr"链接.

- weak(弱类型)

    "weak"链接有和"linkonece"链接相同合并语义,除此以外没有引用全局"weak"链接可能不会被丢弃.在C源码中这用于"weak"声明的全局值

- common(共同)
    
    "common"链接是和"weak"链接最相似的，但是他们被用于在C语言中暂时定义,例如在全局范围中"int X;"."common"链接的符号用和"weak"符号相同的方法合并,并且他们可能被删除如果没有被引用."common"符号可能没有显示的节,必须有零初始值,可能不被"constant"标记.函数和别名可能没有common链接.

- extern_weak(外部弱类型)

    这个链接的语义遵循ELF对象文件模型:这个符号是"weak"直到它被连接,如果没有被连接，这个符号会成为null而不是成为一个未定义的引用.

- linkonce_odr,weak_odr

    一些语言允许不同的全局值合并,例如有两个不同语义的函数.其他语言,例如C++,确保只有相等的全局值永久合并(一次定义原则--"ODR").这样的语言可以使用这个linkonce_odr和weak_odr链接类型表明这个全局值只能够和相等的全局值合并.这些链接类型在其他方面和他们的非-odr版本相同.

- external(外部的)

   如果上面的符号都没被使用,这个全局值是外部可访问的,这意味着它参与连接并且能够被用来解决外部符号引用.

函数声明有任何"external"或者"extern_weak"链接类型是违反规则的 

#### Calling Conventions(调用约定)
LLVM函数，calls和invokes都可以具有为调用指定的可选调用约定.这个任何一对动态调用方和被调用方的调用约定必须匹配，或者程序的行为是没有定义的.按照下面的调用约定在LLVM是被支持的，或者可能在将来被添加
    
- “ccc” - 调用约定

    这个调用约定(如果没有其他指定的调用约定这是默认的)匹配C的调用约定.在声明原型和实现函数的定义中，这个调用约定支持可变参函数和容忍一些不匹配.(像正常的C)
   
- “fastcc” - 最快的调用约定

    这个调用约定企图尽可能快的完成调用(例如在寄存器中传递东西).这个调用约定允许目标使用任何为了这个目标想要生成快速代码的技巧,不需要有符合外部指定的ABI.在这种情况下，只有尾部调用能被优化，the CHC or the HIPE 约定使用了它.这个调用约定不支持可变参数并且要求所有调用方的原型准确匹配函数定义的原型.

- “coldcc” - 冷调用约定
